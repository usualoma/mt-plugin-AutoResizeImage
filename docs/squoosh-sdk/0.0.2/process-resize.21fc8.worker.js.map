{"version":3,"sources":["webpack:///./codecs/resize/pkg/resize.js","webpack:///./src/codecs/resize/processor.ts","webpack:///./src/codecs/resize/util.ts"],"names":["cachegetUint8Memory","getUint8Memory","buffer","resize_bg","Uint8Array","WASM_VECTOR_LEN","cachegetInt32Memory","resize","input_image","input_width","input_height","output_width","output_height","typ_idx","premultiply","color_space_conversion","arg","ptr","length","set","passArray8ToWasm","memi32","Int32Array","v0","len","subarray","getArrayU8FromWasm","retptr","slice","__webpack_require__","d","__webpack_exports__","processor_resize","resizeMethods","async","data","opts","input","fitMethod","sx","sy","sw","sh","dw","dh","endAspect","newSh","newSw","getContainOffsets","width","height","inputPixels","Uint32Array","y","start","copyWithin","ImageData","Uint8ClampedArray","crop","Math","round","result","indexOf","method","linearRGB"],"mappings":"yEAEA,IAAIA,EAAsB,KAC1B,SAASC,IAIL,OAH4B,OAAxBD,GAAgCA,EAAoBE,SAAWC,EAAA,EAAYD,SAC3EF,EAAsB,IAAII,WAAWD,EAAA,EAAYD,SAE9CF,EAGX,IAAIK,EAAkB,EAStB,IAAIC,EAAsB,KAsBnB,SAASC,EAAOC,EAAaC,EAAaC,EAAcC,EAAcC,EAAeC,EAASC,EAAaC,GAElGZ,EAAA,EADG,EA9BnB,SAA0Ba,GACtB,MAAMC,EAAMd,EAAA,EAAoC,EAAba,EAAIE,QAGvC,OAFAjB,IAAiBkB,IAAIH,EAAKC,EAAM,GAChCZ,EAAkBW,EAAIE,OACfD,EA2ByBG,CAAiBZ,GAAcH,EAAiBI,EAAaC,EAAcC,EAAcC,EAAeC,EAASC,EAAaC,GAD9J,MAEMM,GAvBsB,OAAxBf,GAAgCA,EAAoBJ,SAAWC,EAAA,EAAYD,SAC3EI,EAAsB,IAAIgB,WAAWnB,EAAA,EAAYD,SAE9CI,GAqBDiB,EAlBV,SAA4BN,EAAKO,GAC7B,OAAOvB,IAAiBwB,SAASR,EAAM,EAAGA,EAAM,EAAIO,GAiBzCE,CAAmBL,EAAOM,GAAiBN,EAAOM,IAAiBC,QAE9E,OADAzB,EAAA,EAAqBkB,EAAOM,GAA0C,EAAzBN,EAAOM,IAC7CJ,EC9CXM,EAAAC,EAAAC,EAAA,2BAAAC,IAmBA,MAAMC,EAAiD,CACrD,WAAY,SAAU,WAAY,YAG7BC,eAAeF,EAAOG,EAAiBC,GAC5C,IAAIC,EAAQF,EAEZ,GAAuB,YAAnBC,EAAKE,UAAyB,CAChC,MAAMC,GAAEA,EAAEC,GAAEA,EAAEC,GAAEA,EAAEC,GAAEA,GC5BjB,SAA2BD,EAAYC,EAAYC,EAAYC,GACpE,MACMC,EAAYF,EAAKC,EAEvB,GAAIC,EAHkBJ,EAAKC,EAGI,CAC7B,MAAMI,EAAQL,EAAKI,EAEnB,MAAO,CAAEJ,KAAIC,GAAII,EAAOP,GAAI,EAAGC,IADhBE,EAAKI,GAAS,GAI/B,MAAMC,EAAQL,EAAKG,EAEnB,MAAO,CAAEH,KAAID,GAAIM,EAAOR,IADTE,EAAKM,GAAS,EACMP,GAAI,GDgBVQ,CAAkBb,EAAKc,MAAOd,EAAKe,OAAQd,EAAKa,MAAOb,EAAKc,QACvFb,EAzBJ,SAAcF,EAAiBI,EAAYC,EAAYC,EAAYC,GACjE,MAAMS,EAAc,IAAIC,YAAYjB,EAAKA,KAAKjC,QAG9C,IAAK,IAAImD,EAAI,EAAGA,EAAIX,EAAIW,GAAK,EAAG,CAC9B,MAAMC,GAAUD,EAAIb,GAAML,EAAKc,MAASV,EACxCY,EAAYI,WAAWF,EAAIZ,EAAIa,EAAOA,EAAQb,GAGhD,OAAO,IAAIe,UACT,IAAIC,kBAAkBN,EAAYjD,OAAO0B,MAAM,EAAGa,EAAKC,EAAK,IAC5DD,EAAIC,GAcIgB,CAAKrB,EAAOsB,KAAKC,MAAMrB,GAAKoB,KAAKC,MAAMpB,GAAKmB,KAAKC,MAAMnB,GAAKkB,KAAKC,MAAMlB,IAGjF,MAAMmB,EAAStD,EACb,IAAIH,WAAWiC,EAAMF,KAAKjC,QAASmC,EAAMY,MAAOZ,EAAMa,OAAQd,EAAKa,MAAOb,EAAKc,OAC/EjB,EAAc6B,QAAQ1B,EAAK2B,QAAS3B,EAAKtB,YAAasB,EAAK4B,WAG7D,OAAO,IAAIR,UAAU,IAAIC,kBAAkBI,EAAO3D,QAASkC,EAAKa,MAAOb,EAAKc,U","file":"process-resize.21fc8.worker.js","sourcesContent":["import * as wasm from './resize_bg.wasm';\n\nlet cachegetUint8Memory = null;\nfunction getUint8Memory() {\n    if (cachegetUint8Memory === null || cachegetUint8Memory.buffer !== wasm.memory.buffer) {\n        cachegetUint8Memory = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachegetUint8Memory;\n}\n\nlet WASM_VECTOR_LEN = 0;\n\nfunction passArray8ToWasm(arg) {\n    const ptr = wasm.__wbindgen_malloc(arg.length * 1);\n    getUint8Memory().set(arg, ptr / 1);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n\nlet cachegetInt32Memory = null;\nfunction getInt32Memory() {\n    if (cachegetInt32Memory === null || cachegetInt32Memory.buffer !== wasm.memory.buffer) {\n        cachegetInt32Memory = new Int32Array(wasm.memory.buffer);\n    }\n    return cachegetInt32Memory;\n}\n\nfunction getArrayU8FromWasm(ptr, len) {\n    return getUint8Memory().subarray(ptr / 1, ptr / 1 + len);\n}\n/**\n* @param {Uint8Array} input_image\n* @param {number} input_width\n* @param {number} input_height\n* @param {number} output_width\n* @param {number} output_height\n* @param {number} typ_idx\n* @param {boolean} premultiply\n* @param {boolean} color_space_conversion\n* @returns {Uint8Array}\n*/\nexport function resize(input_image, input_width, input_height, output_width, output_height, typ_idx, premultiply, color_space_conversion) {\n    const retptr = 8;\n    const ret = wasm.resize(retptr, passArray8ToWasm(input_image), WASM_VECTOR_LEN, input_width, input_height, output_width, output_height, typ_idx, premultiply, color_space_conversion);\n    const memi32 = getInt32Memory();\n    const v0 = getArrayU8FromWasm(memi32[retptr / 4 + 0], memi32[retptr / 4 + 1]).slice();\n    wasm.__wbindgen_free(memi32[retptr / 4 + 0], memi32[retptr / 4 + 1] * 1);\n    return v0;\n}\n\n","import { WorkerResizeOptions } from './processor-meta';\nimport { getContainOffsets } from './util';\nimport { resize as codecResize } from '../../../codecs/resize/pkg';\n\nfunction crop(data: ImageData, sx: number, sy: number, sw: number, sh: number): ImageData {\n  const inputPixels = new Uint32Array(data.data.buffer);\n\n  // Copy within the same buffer for speed and memory efficiency.\n  for (let y = 0; y < sh; y += 1) {\n    const start = ((y + sy) * data.width) + sx;\n    inputPixels.copyWithin(y * sw, start, start + sw);\n  }\n\n  return new ImageData(\n    new Uint8ClampedArray(inputPixels.buffer.slice(0, sw * sh * 4)),\n    sw, sh,\n  );\n}\n\n/** Resize methods by index */\nconst resizeMethods: WorkerResizeOptions['method'][] = [\n  'triangle', 'catrom', 'mitchell', 'lanczos3',\n];\n\nexport async function resize(data: ImageData, opts: WorkerResizeOptions): Promise<ImageData> {\n  let input = data;\n\n  if (opts.fitMethod === 'contain') {\n    const { sx, sy, sw, sh } = getContainOffsets(data.width, data.height, opts.width, opts.height);\n    input = crop(input, Math.round(sx), Math.round(sy), Math.round(sw), Math.round(sh));\n  }\n\n  const result = codecResize(\n    new Uint8Array(input.data.buffer), input.width, input.height, opts.width, opts.height,\n    resizeMethods.indexOf(opts.method), opts.premultiply, opts.linearRGB,\n  );\n\n  return new ImageData(new Uint8ClampedArray(result.buffer), opts.width, opts.height);\n}\n","export function getContainOffsets(sw: number, sh: number, dw: number, dh: number) {\n  const currentAspect = sw / sh;\n  const endAspect = dw / dh;\n\n  if (endAspect > currentAspect) {\n    const newSh = sw / endAspect;\n    const newSy = (sh - newSh) / 2;\n    return { sw, sh: newSh, sx: 0, sy: newSy };\n  }\n\n  const newSw = sh * endAspect;\n  const newSx = (sw - newSw) / 2;\n  return { sh, sw: newSw, sx: newSx, sy: 0 };\n}\n"],"sourceRoot":""}