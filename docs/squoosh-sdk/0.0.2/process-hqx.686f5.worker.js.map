{"version":3,"sources":["webpack:///./codecs/hqx/pkg/squooshhqx.js","webpack:///./src/codecs/hqx/processor.ts"],"names":["cachegetUint32Memory","getUint32Memory","buffer","squooshhqx_bg","Uint32Array","WASM_VECTOR_LEN","cachegetInt32Memory","resize","input_image","input_width","input_height","factor","arg","ptr","length","set","passArray32ToWasm","memi32","Int32Array","v0","len","subarray","getArrayU32FromWasm","retptr","slice","async","hqx","data","opts","input","result","width","height","ImageData","Uint8ClampedArray","__webpack_require__","d","__webpack_exports__"],"mappings":"yEAEA,IAAIA,EAAuB,KAC3B,SAASC,IAIL,OAH6B,OAAzBD,GAAiCA,EAAqBE,SAAWC,EAAA,EAAYD,SAC7EF,EAAuB,IAAII,YAAYD,EAAA,EAAYD,SAEhDF,EAGX,IAAIK,EAAkB,EAStB,IAAIC,EAAsB,KAkBnB,SAASC,EAAOC,EAAaC,EAAaC,EAAcC,GAE/CR,EAAA,EADG,EA1BnB,SAA2BS,GACvB,MAAMC,EAAMV,EAAA,EAAoC,EAAbS,EAAIE,QAGvC,OAFAb,IAAkBc,IAAIH,EAAKC,EAAM,GACjCR,EAAkBO,EAAIE,OACfD,EAuByBG,CAAkBR,GAAcH,EAAiBI,EAAaC,EAAcC,GAD5G,MAEMM,GAnBsB,OAAxBX,GAAgCA,EAAoBJ,SAAWC,EAAA,EAAYD,SAC3EI,EAAsB,IAAIY,WAAWf,EAAA,EAAYD,SAE9CI,GAiBDa,EAdV,SAA6BN,EAAKO,GAC9B,OAAOnB,IAAkBoB,SAASR,EAAM,EAAGA,EAAM,EAAIO,GAa1CE,CAAoBL,EAAOM,GAAiBN,EAAOM,IAAiBC,QAE/E,OADArB,EAAA,EAAqBc,EAAOM,GAA0C,EAAzBN,EAAOM,IAC7CJ,ECxCJM,eAAeC,EACpBC,EACAC,GAEA,MAAMC,EAAQF,EACRG,EAASvB,EACb,IAAIH,YAAYyB,EAAMF,KAAKzB,QAC3B2B,EAAME,MACNF,EAAMG,OACNJ,EAAKjB,QAEP,OAAO,IAAIsB,UACT,IAAIC,kBAAkBJ,EAAO5B,QAC7ByB,EAAKI,MAAQH,EAAKjB,OAClBgB,EAAKK,OAASJ,EAAKjB,QAjBvBwB,EAAAC,EAAAC,EAAA,wBAAAX,K","file":"process-hqx.686f5.worker.js","sourcesContent":["import * as wasm from './squooshhqx_bg.wasm';\n\nlet cachegetUint32Memory = null;\nfunction getUint32Memory() {\n    if (cachegetUint32Memory === null || cachegetUint32Memory.buffer !== wasm.memory.buffer) {\n        cachegetUint32Memory = new Uint32Array(wasm.memory.buffer);\n    }\n    return cachegetUint32Memory;\n}\n\nlet WASM_VECTOR_LEN = 0;\n\nfunction passArray32ToWasm(arg) {\n    const ptr = wasm.__wbindgen_malloc(arg.length * 4);\n    getUint32Memory().set(arg, ptr / 4);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n\nlet cachegetInt32Memory = null;\nfunction getInt32Memory() {\n    if (cachegetInt32Memory === null || cachegetInt32Memory.buffer !== wasm.memory.buffer) {\n        cachegetInt32Memory = new Int32Array(wasm.memory.buffer);\n    }\n    return cachegetInt32Memory;\n}\n\nfunction getArrayU32FromWasm(ptr, len) {\n    return getUint32Memory().subarray(ptr / 4, ptr / 4 + len);\n}\n/**\n* @param {Uint32Array} input_image\n* @param {number} input_width\n* @param {number} input_height\n* @param {number} factor\n* @returns {Uint32Array}\n*/\nexport function resize(input_image, input_width, input_height, factor) {\n    const retptr = 8;\n    const ret = wasm.resize(retptr, passArray32ToWasm(input_image), WASM_VECTOR_LEN, input_width, input_height, factor);\n    const memi32 = getInt32Memory();\n    const v0 = getArrayU32FromWasm(memi32[retptr / 4 + 0], memi32[retptr / 4 + 1]).slice();\n    wasm.__wbindgen_free(memi32[retptr / 4 + 0], memi32[retptr / 4 + 1] * 4);\n    return v0;\n}\n\n","import { resize } from '../../../codecs/hqx/pkg';\nimport { HqxOptions } from './processor-meta';\n\nexport async function hqx(\n  data: ImageData,\n  opts: HqxOptions,\n): Promise<ImageData> {\n  const input = data;\n  const result = resize(\n    new Uint32Array(input.data.buffer),\n    input.width,\n    input.height,\n    opts.factor,\n  );\n  return new ImageData(\n    new Uint8ClampedArray(result.buffer),\n    data.width * opts.factor,\n    data.height * opts.factor,\n  );\n}\n"],"sourceRoot":""}