{"version":3,"sources":["webpack:///./node_modules/idb-keyval/dist/idb-keyval.mjs","webpack:///./src/lib/sw-bridge.ts"],"names":["__webpack_require__","d","__webpack_exports__","get","set","Store","[object Object]","dbName","storeName","this","_dbp","Promise","resolve","reject","openreq","indexedDB","open","onerror","error","onsuccess","result","onupgradeneeded","createObjectStore","type","callback","then","db","transaction","oncomplete","onabort","objectStore","store","getDefaultStore","key","req","_withIDBStore","value","put","r","__webpack__serviceworker__1","getSharedImage","offliner","mainAppLoaded","idb_keyval__WEBPACK_IMPORTED_MODULE_0__","async","updateReady","reg","waiting","installing","addEventListener","once","installingWorker","state","onmessage","event","data","action","file","navigator","serviceWorker","removeEventListener","controller","postMessage","showSnack","PRERENDER","register","hasController","location","reload","timeout","getRegistration","actions","skipWaiting","Object","active","getMostActiveServiceWorker"],"mappings":"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","file":"sw-bridge.397e8.js","sourcesContent":["class Store {\r\n    constructor(dbName = 'keyval-store', storeName = 'keyval') {\r\n        this.storeName = storeName;\r\n        this._dbp = new Promise((resolve, reject) => {\r\n            const openreq = indexedDB.open(dbName, 1);\r\n            openreq.onerror = () => reject(openreq.error);\r\n            openreq.onsuccess = () => resolve(openreq.result);\r\n            // First time setup: create an empty object store\r\n            openreq.onupgradeneeded = () => {\r\n                openreq.result.createObjectStore(storeName);\r\n            };\r\n        });\r\n    }\r\n    _withIDBStore(type, callback) {\r\n        return this._dbp.then(db => new Promise((resolve, reject) => {\r\n            const transaction = db.transaction(this.storeName, type);\r\n            transaction.oncomplete = () => resolve();\r\n            transaction.onabort = transaction.onerror = () => reject(transaction.error);\r\n            callback(transaction.objectStore(this.storeName));\r\n        }));\r\n    }\r\n}\r\nlet store;\r\nfunction getDefaultStore() {\r\n    if (!store)\r\n        store = new Store();\r\n    return store;\r\n}\r\nfunction get(key, store = getDefaultStore()) {\r\n    let req;\r\n    return store._withIDBStore('readonly', store => {\r\n        req = store.get(key);\r\n    }).then(() => req.result);\r\n}\r\nfunction set(key, value, store = getDefaultStore()) {\r\n    return store._withIDBStore('readwrite', store => {\r\n        store.put(value, key);\r\n    });\r\n}\r\nfunction del(key, store = getDefaultStore()) {\r\n    return store._withIDBStore('readwrite', store => {\r\n        store.delete(key);\r\n    });\r\n}\r\nfunction clear(store = getDefaultStore()) {\r\n    return store._withIDBStore('readwrite', store => {\r\n        store.clear();\r\n    });\r\n}\r\nfunction keys(store = getDefaultStore()) {\r\n    const keys = [];\r\n    return store._withIDBStore('readonly', store => {\r\n        // This would be store.getAllKeys(), but it isn't supported by Edge or Safari.\r\n        // And openKeyCursor isn't supported by Safari.\r\n        (store.openKeyCursor || store.openCursor).call(store).onsuccess = function () {\r\n            if (!this.result)\r\n                return;\r\n            keys.push(this.result.key);\r\n            this.result.continue();\r\n        };\r\n    }).then(() => keys);\r\n}\n\nexport { Store, get, set, del, clear, keys };\n","import { get, set } from 'idb-keyval';\n\n// Just for TypeScript\nimport SnackBarElement from './SnackBar';\n\n/** Tell the service worker to skip waiting */\nasync function skipWaiting() {\n  const reg = await navigator.serviceWorker.getRegistration();\n  if (!reg || !reg.waiting) return;\n  reg.waiting.postMessage('skip-waiting');\n}\n\n/** Find the service worker that's 'active' or closest to 'active' */\nasync function getMostActiveServiceWorker() {\n  const reg = await navigator.serviceWorker.getRegistration();\n  if (!reg) return null;\n  return reg.active || reg.waiting || reg.installing;\n}\n\n/** Wait for an installing worker */\nasync function installingWorker(reg: ServiceWorkerRegistration): Promise<ServiceWorker> {\n  if (reg.installing) return reg.installing;\n  return new Promise<ServiceWorker>((resolve) => {\n    reg.addEventListener(\n      'updatefound',\n      () => resolve(reg.installing!),\n      { once: true },\n    );\n  });\n}\n\n/** Wait a service worker to become waiting */\nasync function updateReady(reg: ServiceWorkerRegistration): Promise<void> {\n  if (reg.waiting) return;\n  const installing = await installingWorker(reg);\n  return new Promise<void>((resolve) => {\n    installing.addEventListener('statechange', () => {\n      if (installing.state === 'installed') resolve();\n    });\n  });\n}\n\n/** Wait for a shared image */\nexport function getSharedImage(): Promise<File> {\n  return new Promise((resolve) => {\n    const onmessage = (event: MessageEvent) => {\n      if (event.data.action !== 'load-image') return;\n      resolve(event.data.file);\n      navigator.serviceWorker.removeEventListener('message', onmessage);\n    };\n\n    navigator.serviceWorker.addEventListener('message', onmessage);\n\n    // This message is picked up by the service worker - it's how it knows we're ready to receive\n    // the file.\n    navigator.serviceWorker.controller!.postMessage('share-ready');\n  });\n}\n\n/** Set up the service worker and monitor changes */\nexport async function offliner(showSnack: SnackBarElement['showSnackbar']) {\n  // This needs to be a typeof because Webpack.\n  if (typeof PRERENDER === 'boolean') return;\n\n  if (process.env.NODE_ENV === 'production') {\n    navigator.serviceWorker.register('../sw');\n  }\n\n  const hasController = !!navigator.serviceWorker.controller;\n\n  // Look for changes in the controller\n  navigator.serviceWorker.addEventListener('controllerchange', async () => {\n    // Is it the first install?\n    if (!hasController) {\n      showSnack('Ready to work offline', { timeout: 5000 });\n      return;\n    }\n\n    // Otherwise reload (the user will have agreed to this).\n    location.reload();\n  });\n\n  // If we don't have a controller, we don't need to check for updates â€“ we've just loaded from the\n  // network.\n  if (!hasController) return;\n\n  const reg = await navigator.serviceWorker.getRegistration();\n  // Service worker not registered yet.\n  if (!reg) return;\n  // Look for updates\n  await updateReady(reg);\n\n  // Ask the user if they want to update.\n  const result = await showSnack('Update available', {\n    actions: ['reload', 'dismiss'],\n  });\n\n  // Tell the waiting worker to activate, this will change the controller and cause a reload (see\n  // 'controllerchange')\n  if (result === 'reload') skipWaiting();\n}\n\n/**\n * Tell the service worker the main app has loaded. If it's the first time the service worker has\n * heard about this, cache the heavier assets like codecs.\n */\nexport async function mainAppLoaded() {\n  // If the user has already interacted, no need to tell the service worker anything.\n  const userInteracted = await get<boolean | undefined>('user-interacted');\n  if (userInteracted) return;\n  set('user-interacted', true);\n  const serviceWorker = await getMostActiveServiceWorker();\n  if (!serviceWorker) return; // Service worker not installing yet.\n  serviceWorker.postMessage('cache-all');\n}\n"],"sourceRoot":""}